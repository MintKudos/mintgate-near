<!-- AUTOGENERATED doc on 2021-04-30 08:42:50.230988 UTC, do not modify! -->
# Contract

This module implements the NFT contract for the MintGate marketplace.
The MintGate marketplace consists of two main entities:

- `Collectible`s
- `Token`s

A `Collectible` represents a content that a creator wants to tokenize.
A `Token` represents a copy of a given `Collectible`.

In addition, this contract implements the following NFT standards:

- Non-Fungible Token NEP-171
<https://github.com/near/NEPs/blob/master/specs/Standards/NonFungibleToken/Core.md>
- Non-Fungible Token Metadata NEP-177
<https://github.com/near/NEPs/blob/master/specs/Standards/NonFungibleToken/Metadata.md>
- Non-Fungible Token Approval Management NEP-178
<https://github.com/near/NEPs/blob/master/specs/Standards/NonFungibleToken/ApprovalManagement.md>
- Non-Fungible Token Enumeration NEP-181
<https://github.com/near/NEPs/blob/master/specs/Standards/NonFungibleToken/Enumeration.md>

## Methods for NftContract

### :rocket: `init` (*constructor*)

```typescript
init: { admin_id: ValidAccountId, metadata: NFTContractMetadata, min_royalty: Fraction, max_royalty: Fraction, mintgate_fee: Fraction, mintgate_fee_account_id: ValidAccountId };
```

Initializes the contract.
This contract methods needs to be explicitely called
since the default construction of the contract will panic.

- `admin_id` is the valid account that is allowed to perform certain operations.
- `metadata` represents the general information of the contract.
- `min_royalty` and `max_royalty` indicates what must be the max and min royalty respectively when creating a collectible.
- `mintgate_fee` is the percetange to be paid to `mintgate_fee_account_id` for each sale.

### :writing_hand: `create_collectible`

```typescript
create_collectible(args: { gate_id: ValidGateId, title: string, description: string, supply: number, royalty: Fraction, media: string|null, media_hash: string|null, reference: string|null, reference_hash: string|null }, gas?: any): Promise<void>;
```

Creates a new `Collectible`, identified by `gate_id`.
The `supply` indicates maximum supply for this collectible.
The `royalty` indicates the royalty (as percentage) paid to the creator (`predecessor_account_id`).
This royalty is paid when any `Token` is being resold in any marketplace.

The sum of `royalty` and `mintgate_fee` should be less than `1`.
Panics otherwise.
This is to be able to make payouts all participants.

See <https://github.com/epam/mintgate/issues/3>.

### :eyeglasses: `get_collectible_by_gate_id`

```typescript
get_collectible_by_gate_id(args: { gate_id: ValidGateId }): Promise<Collectible|null>;
```

Returns the `Collectible` with the given `gate_id`.
Panics otherwise.

See <https://github.com/epam/mintgate/issues/16>.

### :eyeglasses: `get_collectibles_by_creator`

```typescript
get_collectibles_by_creator(args: { creator_id: ValidAccountId }): Promise<Collectible[]>;
```

Returns all `Collectible`s created by `creator_id`.

See <https://github.com/epam/mintgate/issues/15>.

### :writing_hand: `delete_collectible`

```typescript
delete_collectible(args: { gate_id: ValidGateId }, gas?: any): Promise<void>;
```

Deletes the given `Collectible` by `gate_id`.
The collectible can only be deleted if there are no minted tokens.
Moreover, only the `creator_id` of the collectible or
the contract `admin_id` are allowed to delete the collectible.

### :writing_hand: `claim_token`

```typescript
claim_token(args: { gate_id: ValidGateId }, gas?: any): Promise<TokenId>;
```

Claims a `Token` for the `Collectible` indicated by `gate_id`.
The claim is on behalf the `predecessor_account_id`.
Returns a `TokenId` that represents this claim.
If the given `gate_id` has exhausted its supply, this call will panic.

See <https://github.com/epam/mintgate/issues/6>.

### :writing_hand: `burn_token`

```typescript
burn_token(args: { token_id: TokenId }, gas?: any): Promise<void>;
```

Burns (deletes) the `Token` identifed by `token_id`.
Only the `owner_id` can burn the token.

After succefully delete the token,
a cross-contract call  is made to `nft_on_revoke` for each approval
to delist from their marketplaces.

### :eyeglasses: `get_tokens_by_owner`

```typescript
get_tokens_by_owner(args: { owner_id: ValidAccountId }): Promise<Token[]>;
```

Returns all `Token`s owned by `owner_id`.

### :eyeglasses: `get_tokens_by_owner_and_gate_id`

```typescript
get_tokens_by_owner_and_gate_id(args: { gate_id: ValidGateId, owner_id: ValidAccountId }): Promise<Token[]>;
```

Returns all tokens claimed by `owner_id` belonging to `gate_id`.

See <https://github.com/epam/mintgate/issues/14>.

### :writing_hand: `batch_approve`

```typescript
batch_approve(args: { tokens: [TokenId, U128][], account_id: ValidAccountId }, gas?: any): Promise<void>;
```

Approves a batch of tokens, similar to `nft_approve`.
Each approval contains the `TokenId` to approve and the minimum price to sell the token for.
`account_id` indicates the market account contract where list these tokens.

## Methods for `NonFungibleTokenCore` interface

### :writing_hand: `nft_transfer`

```typescript
nft_transfer(args: { receiver_id: ValidAccountId, token_id: TokenId, enforce_approval_id: U64|null, memo: string|null }, gas?: any): Promise<void>;
```

Transfer the token `token_id` to the `receiver_id` account.

See <https://github.com/epam/mintgate/issues/18>.

### :eyeglasses: `nft_payout`

```typescript
nft_payout(args: { token_id: TokenId, balance: U128 }): Promise<Payout>;
```

Query whom to be paid out for a given `token_id`, derived from some `balance`.
For example, given the following settings for the NFT contract and collectible `gate_id`:

- `mintgate_fee`: `25/1000` (2.5%)
- `royalty`: `30/100` (30%)

Then `nft_payout(token_id, 5_000_000)` will return

- `mintgate_fee_account_id` -> 125_000
- `collectible.creator_id` -> 3_375_000
- `token.owner_id` -> 1_500_000

for any `token_id` claimed from `gate_id`.

This is part of an ongoing (yet not settled) NEP spec:
<https://github.com/thor314/NEPs/blob/patch-5/specs/Standards/NonFungibleToken/payouts.md>

### :writing_hand: `nft_transfer_payout`

```typescript
nft_transfer_payout(args: { receiver_id: ValidAccountId, token_id: TokenId, approval_id: U64|null, memo: string|null, balance: U128|null }, gas?: any): Promise<Payout|null>;
```

Attempts to transfer the token.
Afterwards returns the payout data.
Effectively it is calling `nft_transfer` followed by `nft_payout`.

This is part of an ongoing (yet not settled) NEP spec:
<https://github.com/thor314/NEPs/blob/patch-5/specs/Standards/NonFungibleToken/payouts.md>

### :eyeglasses: `nft_token`

```typescript
nft_token(args: { token_id: TokenId }): Promise<Token|null>;
```

Returns the token identified by `token_id`.
Or `null` if the `token_id` was not found.

See <https://github.com/epam/mintgate/issues/17>.

## Methods for `NonFungibleTokenMetadata` interface

### :eyeglasses: `nft_metadata`

```typescript
nft_metadata(): Promise<NFTContractMetadata>;
```

Returns the NFT metadata for this contract.

## Methods for `NonFungibleTokenApprovalMgmt` interface

### :writing_hand: `nft_approve`

```typescript
nft_approve(args: { token_id: TokenId, account_id: ValidAccountId, msg: string|null }, gas?: any): Promise<void>;
```

Allows `account_id` to transfer `token_id` on behalf of its owner.
The `msg` argument allows the caller to pass into additional information.
A contract implementing the `nft_on_approve` methods must be
deployed into `account_id`.

### :writing_hand: `nft_revoke`

```typescript
nft_revoke(args: { token_id: TokenId, account_id: ValidAccountId }, gas?: any): Promise<void>;
```

Revokes approval for `token_id` from `account_id`.

### :writing_hand: `nft_revoke_all`

```typescript
nft_revoke_all(args: { token_id: TokenId }, gas?: any): Promise<void>;
```

Revokes all approval for `token_id`.

## Methods for `NonFungibleTokenEnumeration` interface

### :eyeglasses: `nft_total_supply`

```typescript
nft_total_supply(): Promise<U64>;
```

Returns the total token supply.

### :eyeglasses: `nft_tokens`

```typescript
nft_tokens(args: { from_index: U64|null, limit: number|null }): Promise<Token[]>;
```

Returns all or paginated `Token`s minted by this contract.
Pagination is given by:

- `from_index` the index to start fetching tokens.
- `limit` indicates how many tokens will be at most returned.

### :eyeglasses: `nft_supply_for_owner`

```typescript
nft_supply_for_owner(args: { account_id: ValidAccountId }): Promise<U64>;
```

Returns how many `Token`s are owned by `account_id`.

### :eyeglasses: `nft_tokens_for_owner`

```typescript
nft_tokens_for_owner(args: { account_id: ValidAccountId, from_index: U64|null, limit: number|null }): Promise<Token[]>;
```

Returns all or paginated `Token`s owned by `account_id`.
Pagination is given by:

- `from_index` the index to start fetching tokens.
- `limit` indicates how many tokens will be at most returned.

### :eyeglasses: `nft_token_uri`

```typescript
nft_token_uri(args: { token_id: TokenId }): Promise<string|null>;
```

Gets the URI for the given `token_id`.
The uri combines the `base_uri` from the contract metadata and
the `gate_id` from the token.

---

References

- :rocket: Initialization method. Needs to be called right after deployment.
- :eyeglasses: View only method, *i.e.*, does not modify the contract state.
- :writing_hand: Call method, i.e., does modify the contract state.
- &#x24C3; Payable method, i.e., call needs to have an attached NEAR deposit.

---

*This documentation was generated with* **near-md v0.2.16** <https://github.com/epam/near-syn> *on 2021-04-30 08:42:50.230988 UTC*
